name: Build, Run, Capture and Push Images (TP Final)

on:
  workflow_dispatch:
  push:
    branches: [ main ]

env:
  SUBNET: 192.168.67.0/24
  SERVER_IP: 192.168.67.10
  NETWORK_NAME: red_tp_tcp
  DOCKER_IMAGE_SERVER: imagen_servidor_tcp
  DOCKER_IMAGE_CLIENT: imagen_cliente_tcp
  SERVER_TAG: itestyr/2025_tp_final:gautehr_angel_67_servidor
  CLIENT_TAG: itestyr/2025_tp_final:gautehr_angel_67_cliente

jobs:
  build-run-capture:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build server image
        run: docker build -t $DOCKER_IMAGE_SERVER:latest ./server/

      - name: Build client image
        run: docker build -t $DOCKER_IMAGE_CLIENT:latest ./client/

      - name: Tag images for Docker Hub (itestyr)
        run: |
          echo "Tagging images -> $SERVER_TAG and $CLIENT_TAG"
          docker tag $DOCKER_IMAGE_SERVER:latest $SERVER_TAG
          docker tag $DOCKER_IMAGE_CLIENT:latest $CLIENT_TAG
          docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}" | sed -n '1,20p'

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Push images to Docker Hub (itestyr)
        run: |
          docker push $SERVER_TAG
          docker push $CLIENT_TAG

      - name: Create docker network (if not exists)
        run: |
          docker network inspect "$NETWORK_NAME" >/dev/null 2>&1 || docker network create --driver bridge --subnet $SUBNET $NETWORK_NAME

      - name: Start server container (detached)
        run: |
          docker rm -f servidor_tcp >/dev/null 2>&1 || true
          docker run -d --name servidor_tcp --net $NETWORK_NAME --ip $SERVER_IP $DOCKER_IMAGE_SERVER:latest
          echo "âœ… Servidor iniciado en segundo plano"
          sleep 5  # Espera inicial despuÃ©s del inicio

      - name: Verify server status
        run: |
          echo "=== Estado del contenedor del servidor ==="
          docker ps -a | grep servidor_tcp
          
          echo "=== Logs COMPLETOS del servidor ==="
          docker logs servidor_tcp
          
          echo "=== Verificando proceso interno del servidor ==="
          docker exec servidor_tcp ps aux || echo "No se puede ejecutar ps en el contenedor"
          
          echo "=== Verificando puertos escuchando ==="
          docker exec servidor_tcp netstat -tulpn 2>/dev/null || docker exec servidor_tcp ss -tulpn 2>/dev/null || echo "No se pueden verificar puertos"

      - name: Wait for server to be ready
        run: |
          echo "â³ Esperando a que el servidor estÃ© listo..."
          # Intentar conectarse al puerto 2025 con timeout
          timeout 30 bash -c '
            while ! nc -z $SERVER_IP 2025; do
              echo "Esperando servidor en $SERVER_IP:2025..."
              sleep 3
            done
            echo "âœ… Servidor listo en $SERVER_IP:2025"
          ' || echo "âš ï¸  No se pudo verificar la conectividad, continuando..."

      - name: Install tcpdump and netcat
        run: |
          sudo apt-get update
          sudo apt-get install -y tcpdump netcat-openbsd

      - name: Start tcpdump in background (capture only port 2025, unbuffered)
        run: |
          sudo tcpdump -i any tcp port 2025 -s 0 -w captura_trafico.pcap -U &
          echo $! > /tmp/tcpdump_pid
          sleep 2
          echo "âœ… tcpdump iniciado (PID: $(cat /tmp/tcpdump_pid))"
          ls -lh captura_trafico.pcap || echo "âš ï¸  Archivo pcap aÃºn no creado"

      - name: Debug before client
        run: |
          echo "=== Estado final antes del cliente ==="
          echo "Servidor IP: $SERVER_IP"
          echo "Network: $NETWORK_NAME"
          docker ps -a
          echo "=== Ãšltimos logs del servidor ==="
          docker logs --tail 20 servidor_tcp

      - name: Run client container (will connect and exit)
        run: |
          echo "ðŸš€ Ejecutando cliente..."
          timeout 60 docker run --rm --name cliente_tcp --net $NETWORK_NAME $DOCKER_IMAGE_CLIENT:latest
          CLIENT_EXIT_CODE=$?
          echo "ðŸ”š Cliente finalizado con cÃ³digo: $CLIENT_EXIT_CODE"
          
          echo "=== Logs del servidor despuÃ©s del cliente ==="
          docker logs --tail 30 servidor_tcp

      - name: Stop tcpdump capture (use SIGINT to flush)
        run: |
          echo "ðŸ›‘ Deteniendo tcpdump..."
          if [ -f /tmp/tcpdump_pid ]; then
            pid=$(cat /tmp/tcpdump_pid)
            sudo kill -2 $pid 2>/dev/null || sudo kill $pid 2>/dev/null || true
            sleep 2
          fi
          echo "=== InformaciÃ³n del archivo pcap ==="
          ls -lh captura_trafico.pcap || echo "âŒ No se encontrÃ³ archivo pcap"
          file captura_trafico.pcap 2>/dev/null || echo "âŒ No se puede analizar archivo pcap"

      - name: Upload pcap artifact
        uses: actions/upload-artifact@v4
        with:
          name: captura_trafico_pcap
          path: captura_trafico.pcap
          if-no-files-found: warn

      - name: Final cleanup and logs
        if: always()
        run: |
          echo "=== Limpieza final y logs completos ==="
          echo "ðŸ§¹ Deteniendo contenedores..."
          docker stop servidor_tcp 2>/dev/null || true
          docker rm -f servidor_tcp 2>/dev/null || true
          
          echo "=== LOGS FINALES DEL SERVIDOR ==="
          docker logs servidor_tcp 2>/dev/null || echo "No hay logs del servidor"